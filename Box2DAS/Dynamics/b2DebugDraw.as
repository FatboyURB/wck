package Box2DAS.Dynamics {		import Box2DAS.*;	import Box2DAS.Collision.*;	import Box2DAS.Collision.Shapes.*;	import Box2DAS.Common.*;	import Box2DAS.Dynamics.*;	import Box2DAS.Dynamics.Contacts.*;	import Box2DAS.Dynamics.Joints.*;	import cmodule.Box2D.*;	import flash.events.*;	import flash.utils.*;	import flash.display.*;		public class b2DebugDraw extends Shape {			/// When debug drawing, multiply coordinates by this value.		public var scale:Number = 0;				/// The world to draw.		public var world:b2World;				/// Drawing options.		public var shapes:Boolean = true;		public var joints:Boolean = true;		public var pairs:Boolean = false;				public function b2DebugDraw(w:b2World = null, s:Number = 0):void {			world = w;			scale = s;		}				public function Draw():void {			graphics.clear();			if(shapes) {				for(var b:b2Body = world.m_bodyList; b; b = b.GetNext()) {					var xf:XF = b.GetTransform();					for(var f:b2Fixture = b.GetFixtureList(); f; f = f.GetNext()) {						DrawShape(f, xf);					}				}			}			if(joints) {				for(var j:b2Joint = world.m_jointList; j; j = j.GetNext()) {					DrawJoint(j);				}			}			if(pairs) {				for(var c:b2Contact = world.GetContactList(); c; c = c.GetNext()) {					DrawPair(c);				}			}		}				public function DrawShape(fixture:b2Fixture, xf:XF):void {			var body:b2Body = fixture.GetBody();			var color:uint;			if(!body.IsActive()) {				color = Color(0.5, 0.5, 0.3)			}			else if(body.GetType() == b2Body.b2_staticBody) {				color = Color(0.5, 0.9, 0.5)			}			else if(body.GetType() == b2Body.b2_kinematicBody) {				color = Color(0.5, 0.5, 0.9);			}			else if(!body.IsAwake()) {				color = Color(0.6, 0.6, 0.6);			}			else {				color = Color(0.9, 0.7, 0.7);			}			switch(fixture.GetType()) {				case b2Shape.e_circle:						var circle:b2CircleShape = fixture.GetShape() as b2CircleShape;						DrawSolidCircle(xf.multiply(circle.m_p.v2), circle.m_radius, xf.r.c1, color);					break;				case b2Shape.e_polygon:					var polygon:b2PolygonShape = fixture.GetShape() as b2PolygonShape;					var vertices:Vector.<V2> = polygon.m_vertices;					for(var i:uint = 0; i < vertices.length; ++i) {						vertices[i] = xf.multiply(vertices[i]);					}					DrawSolidPolygon(vertices, vertices.length, color);					break;			}		}				public function DrawJoint(j:b2Joint):void {			var b1:b2Body = j.GetBodyA();			var b2:b2Body = j.GetBodyB();			var xf1:XF = b1.GetTransform();			var xf2:XF = b2.GetTransform();			var x1:V2 = xf1.p;			var x2:V2 = xf2.p;			var p1:V2 = j.GetAnchorA();			var p2:V2 = j.GetAnchorB();						var color:uint = Color(0.5, 0.8, 0.8);						switch(j.GetType()) {				case b2Joint.e_distanceJoint:					DrawSegment(p1, p2, color);					break;				case b2Joint.e_pulleyJoint:					var pulley:b2PulleyJoint = j as b2PulleyJoint;					var s1:V2 = pulley.GetGroundAnchor1();					var s2:V2 = pulley.GetGroundAnchor2();					DrawSegment(s1, p1, color);					DrawSegment(s2, p2, color);					DrawSegment(s1, s2, color);					break;				case b2Joint.e_mouseJoint:					break;				default:					DrawSegment(x1, p1, color);					DrawSegment(p1, p2, color);					DrawSegment(x2, p2, color);					break;			}		}				public function DrawPair(c:b2Contact):void {			var color:uint = Color(0.3, 0.9, 0.9);			var cA:V2 = c.m_fixtureA.m_aabb.aabb.getCenter();			var cB:V2 = c.m_fixtureB.m_aabb.aabb.getCenter();			DrawSegment(cA, cB, color);		}				public function DrawSolidCircle(center:V2, radius:Number, axis:V2, color:uint):void {			graphics.beginFill(color);			graphics.lineStyle(1, DarkColor(color));			graphics.drawCircle(center.x * scale, center.y * scale, radius * scale);			graphics.endFill();		}				public function DrawSolidPolygon(vertices:Vector.<V2>, vertexCount:uint, color:uint):void {			graphics.beginFill(color);			graphics.lineStyle(1, DarkColor(color));			graphics.moveTo(vertices[vertexCount - 1].x * scale, vertices[vertexCount - 1].y * scale);			for(var i:int = 0; i < vertexCount; ++i) {				graphics.lineTo(vertices[i].x * scale, vertices[i].y * scale);			}			graphics.endFill();		}				public function DrawSegment(p1:V2, p2:V2, color:uint):void {			graphics.lineStyle(1, color, 0.5);			graphics.moveTo(p1.x * scale, p1.y * scale);			graphics.lineTo(p2.x * scale, p2.y * scale);		}				public function Color(red:Number, green:Number, blue:Number):uint {			var r:uint = red * 255;			var g:uint = green * 255;			var b:uint = blue * 255;			return ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF);		}		public function DarkColor(color:uint):uint {			var r:uint = (color & 0xFF0000) >> 16;			var g:uint = (color & 0xFF00) >> 8;			var b:uint = (color & 0xFF);			r /= 2;			g /= 2;			b /= 2;			return ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF);		}	}}
package extras.actor {		import Box2DAS.*;	import Box2DAS.Collision.*;	import Box2DAS.Collision.Shapes.*;	import Box2DAS.Common.*;	import Box2DAS.Dynamics.*;	import Box2DAS.Dynamics.Contacts.*;	import Box2DAS.Dynamics.Joints.*;	import cmodule.Box2D.*;	import wck.*;	import shapes.*;	import misc.*;	import extras.*;	import extras.actor.*;	import flash.utils.*;	import flash.events.*;	import flash.display.*;	import flash.text.*;	import flash.geom.*;		public class Actor extends ShapeBase {				[Inspectable(defaultValue='')]		public var actorAIClass:String = '';				public var g:GroundFinder;		public var ai:ActorAI;				public override function create():void {			if(!ai && actorAIClass != '') {				var cls:Class = getDefinitionByName(actorAIClass) as Class;				ai = new cls();				ai.a = this;			}			autoSleep = false;			bullet = true;			reportBeginContact = true;			reportEndContact = true;			reportPreSolve = true;			reportPostSolve = true;			super.create();			g = new GroundFinder();			g.listenTo(this);			listenOnceWhileVisible(world, StepEvent.STEP, function() {				listenWhileVisible(world, StepEvent.STEP, beforeTimeStep, false, 1);			}, false, 1);			listenWhileVisible(world, StepEvent.STEP, afterTimeStep, false, -20);		}				public function beforeTimeStep(e:StepEvent):void { 			g.clean();			moveContact = null;			if(g.timeAirborne == 0) {				airJumps = 0;				airFromJump = false;							}			if(ai) {				ai.control();			}		}				public function afterTimeStep(e:StepEvent):void {			g.process(gravity);		}				public var moveAirSlop:int = 3;		public var rollOnGround:Boolean = true;		public var allowAirMoveTime:Number = 5;				public function move(d:int):void {			findMoveContact(d);			if(g.timeAirborne == 0 || (!airFromJump && (g.timeAirborne < moveAirSlop))) {				var t:Number = (d == 1) ? g.timeRightAirborne: g.timeLeftAirborne;				if(t > allowAirMoveTime) {					airMove(d);				}				else if(rollOnGround) {					groundRoll(d);				}				else {					groundMove(d);				}						}			else {				if(allowAirMoveTime < g.timeAirborne) {					airMove(d);				}			}		}				public var airMoveQuickTurn:Boolean = false;		public var airMoveInc:Number = .2;		public var airMoveMax:Number = 6;				public function airMove(d:int):void {			applyMoveImpulse(d == 1 ? g.right : g.left, airMoveQuickTurn, airMoveInc, airMoveMax);		}				public var groundMoveQuickTurn:Boolean = true;		public var groundMoveInc:Number = 1;		public var groundMoveMax:Number = 8;				public function groundMove(d:int):void {			applyMoveImpulse(d == 1 ? g.right : g.left, groundMoveQuickTurn, groundMoveInc, groundMoveMax);		}				public function applyMoveImpulse(d:V2, quickTurn:Boolean, inc:Number, max:Number):void {			var lv:V2 = b2body.m_linearVelocity.v2;			var dot:Number = d.dot(lv);			if(dot < max) { /// Don't bother if we're already over the max.				if(quickTurn && dot < 0) {					lv.subtract(V2.multiplyN(d, dot)); // Negate movement in the opposite direction.				}				lv.add(V2.multiplyN(d, inc)); /// New linear velocity.				dot = d.dot(lv);				if(dot > max) { /// Did we go over the maximum?					lv.subtract(V2.multiplyN(d, dot - max)); /// compensate.				}				body.b2body.m_linearVelocity.v2 = lv;			}		}				public var groundRollQuickTurn:Boolean = true;		public var groundRollInc:Number = 6;		public var groundRollMax:Number = 40;				public function groundRoll(d:int):void {			var av:Number = b2body.m_angularVelocity * d;			if(av < groundRollMax) { /// Don't roll more than the maximum.				if(groundRollQuickTurn && av < 0) {					av = Math.max(-groundRollInc, av);				}				av = Math.min(groundRollMax, av + groundRollInc);				b2body.m_angularVelocity = av * d;			}			lubricateContacts();		}				public var allowAirJump:Boolean = true;		public var maxAirJumps:int = 1;		public var airJumps:int = 0;		public var airFromJump:Boolean = false;		public var jumpAirSlop:int = 3;				public function jump():void {			if(g.timeAirborne == 0 || (!airFromJump && g.timeAirborne < jumpAirSlop)) {				applyJump();				airFromJump = true;			}			else if(allowAirJump && (maxAirJumps == 0 || (maxAirJumps > airJumps))) {				applyAirJump();				++airJumps;			}			gotoAndPlay('jump');		}				public var jumpImpulse:Number = 1.7;				public function applyJump():void {			b2body.ApplyImpulse(g.jumpVector.multiplyN(jumpImpulse), b2body.GetWorldCenter());			jumpReaction();		}				public function applyAirJump():void {			var v:V2 = b2body.m_linearVelocity.v2;			var d:Number = v.dot(g.down);			v.subtract(V2.multiplyN(g.down, d));			v.add(V2.multiplyN(g.up, jumpImpulse * b2body.m_invMass));			b2body.m_linearVelocity.v2 = v;		}				public function jumpReaction():void {			g.applyImpulse(jumpImpulse);		}				public function lubricateContacts():void {			for(var i:int = 0; i < g.cl.length; ++i) {				if(g.cl[i] != moveContact) {					g.cl[i].contact.frictionDisabled = true;				}			}		}				public var moveContact:ContactEvent;				public function findMoveContact(d:int):void {			moveContact = (d == 1) ? g.cwRollContact : g.ccwRollContact;		}					}}